# 独立性

正如我们之前所述，一个好的架构必须支持以下几点：

- 系统的用例和操作。
- 系统的维护。
- 系统的开发。
- 系统的部署。

用例

第一点——用例——意味着系统的架构必须支持系统的意图。如果系统是一个购物车应用程序，那么架构必须支持购物车用例。事实上，这是架构师的第一关注点和架构的第一优先事项。架构必须支持用例。

然而，正如我们之前所讨论的，架构对系统行为的影响不大。架构可以留下很少的行为选项。但是影响并不是一切。一个好的架构能够支持行为的最重要的事情是澄清和暴露那些行为，以便系统的意图在架构层面上可见。

一个具有良好架构的购物车应用程序将看起来像一个购物车应用程序。该系统的用例将在该系统的结构中明显可见。开发人员不必寻找行为，因为这些行为将是一级元素，在系统的顶层可见。这些元素将是具有突出位置的类、函数或模块，并且它们将有清晰描述其功能的名称。

第21章“尖叫架构”将更清楚地阐述这一点。

## 运行

架构在支持系统运行方面扮演了更加重要和不那么表面的角色。如果系统必须每秒处理100,000个客户，架构必须支持那种吞吐量和响应时间，以满足每个需要的用例。如果系统必须在毫秒级别查询大型数据立方体，则必须构建这种类型的架构以允许此类操作。

对于一些系统，这意味着将系统的处理元素排列成一组可以在许多不同服务器上并行运行的小型服务。对于其他系统，这将意味着大量轻量级线程共享单个处理器内的单个进程的地址空间。而其他一些系统只需要几个在隔离地址空间中运行的进程。有些系统甚至可以作为简单的单片程序运行在单个进程中。

虽然这看起来很奇怪，但这是一个好架构师所要开放的选择之一。一个写成单块的系统，依赖于这种单块结构，一旦需要升级为多个进程、多个线程或微服务，就不容易实现。相比之下，保持其组件的适当隔离，并不假设这些组件之间的通信手段的架构，将更容易地在系统操作需求随时间变化的线程、进程和服务谱系中进行过渡。

##　开发
架构在支持开发环境方面扮演了重要角色。这时Conway定律就发挥作用了。Conway定律是这样规定的：

> [!NOTE]
> 任何设计系统的组织都会产生一种结构与该组织的通信结构相似的设计。

必须由拥有许多团队和多个关注点的组织开发的系统必须具有促进这些团队独立操作的架构，以便在开发过程中这些团队不会相互干扰。这是通过将系统适当分割为良好隔离、可独立开发的组件来实现的。然后，可以将这些组件分配给可以相互独立工作的团队。

## 部署

架构在确定系统部署的易用性方面也扮演着重要角色。目标是“即时部署”。一个好的架构不依赖于数十个小配置脚本和属性文件调整。它不需要手动创建必须精心排列的目录或文件。一个好的架构可以帮助系统在构建后立即部署。

同样，这是通过适当地分割和隔离系统的组件，包括将整个系统连接在一起并确保每个组件正确启动、集成和监管的主控组件来实现的。

## 保持选择的开放性

好的架构需要平衡各种考虑因素，并且相互满足这些因素的组件结构。听起来很容易，对吧？嗯，对我来说很容易写出来。

现实情况是，实现这种平衡非常困难。问题在于大多数时候我们不知道所有使用案例是什么，也不知道操作约束、团队结构或部署要求。更糟糕的是，即使我们知道了，它们也不可避免地会随着系统的生命周期而改变。简而言之，我们必须达成的目标是模糊且不稳定的。欢迎来到真实的世界。

但并非一切都已经失去：一些架构原则比较容易实现，并且即使你不清楚需要达到的目标，它们也可以帮助平衡这些问题。这些原则帮助我们将系统划分为良好隔离的组件，使我们尽可能地保持选择的开放性，尽可能长时间地保持这种开放性。

通过保持选择的开放性，一个好的架构可以使系统在必须变更的所有方面变得容易。

## 层次分离

考虑使用案例。架构师希望系统的结构支持所有必要的使用案例，但不知道所有这些使用案例是什么。但是，架构师确实知道系统的基本意图。它是一个购物车系统，或者是一个材料清单系统，或者是一个订单处理系统。因此，架构师可以运用单一职责原则和共同封闭原则，将因不同原因而发生变化的事物分离开来，并将因相同原因而发生变化的事物收集在一起——根据系统意图的上下文。

因为不同的原因而发生变化？有一些是很明显的。用户界面的变化与业务规则无关。用例则包含这两个元素。因此，一个好的架构师会想要将用例的UI部分与业务规则部分分开，以便它们可以独立地进行更改，同时保持这些用例可见和清晰。

业务规则本身可能与应用程序紧密相关，也可能更为普遍。例如，输入字段的验证是与应用程序本身密切相关的业务规则。相比之下，账户利息的计算和库存的计数是更与领域相关的业务规则。这两种不同类型的规则将以不同的速率和不同的原因进行更改 - 因此应该将它们分开，以便可以独立更改。

数据库、查询语言甚至模式是与业务规则或用户界面无关的技术细节。它们将以独立于系统其他方面的速率和原因进行更改。

因此，架构应将它们与系统的其他部分分开，以便可以独立更改。

因此，我们将系统划分为解耦的水平层 - UI、特定于应用程序的业务规则、应用程序无关的业务规则和数据库，只是其中的几个举例。

##　解耦模式

现在想想第二个要点所提到的解耦意味着什么：操作。如果使用案例的不同方面被分开了，那么必须以高吞吐量运行的部分很可能已经与必须以低吞吐量运行的部分分开了。如果UI和数据库已经从业务规则中分离出来，那么它们可以在不同的服务器上运行。需要更高带宽的组件可以在多台服务器上进行复制。

简而言之，为了使用案例，我们所做的解耦也有助于操作。然而，为了利用运行效益，解耦必须具有适当的模式。要在独立的服务器上运行，分离的组件不能依赖于在处理器的相同地址空间中一起运行。它们必须是独立的服务，并通过某种网络进行通信。

许多架构师称这些组件为“服务”或“微服务”，具体取决于代码行数的模糊概念。的确，基于服务的架构通常被称为面向服务的架构。

如果这些术语在你的脑海中引起了一些警报，请不要担心。我不会告诉你SoA是最好的可能架构，或者微服务是未来的潮流。这里要说明的是，有时候我们必须将组件分离到服务级别。

记住，一个好的架构留下了选择的余地。解耦模式是其中的一个选择。

在我们进一步探讨这个主题之前，让我们看看另外两个要点。

## 独立可开发性

第三个要点是开发。当组件之间强烈解耦时，团队之间的干扰会减少。如果业务规则不知道用户界面，那么专注于用户界面的团队不会对专注于业务规则的团队造成太大影响。如果用例本身相互解耦，那么专注于添加订单用例的团队不太可能干扰专注于删除订单用例的团队。只要层和用例解耦，系统的架构就会支持团队的组织，无论它们是按功能组织、按组件组织、按层组织还是其他变体。

## 独立可部署性

用例和层之间的解耦也为部署提供了高度的灵活性。如果解耦做得好，那么在运行系统中热插拔层和用例应该是可行的。添加新的用例可能只需要向系统添加一些新的jar文件或服务，而不需要改变其他部分。

## 复制

建筑师们经常会陷入一个陷阱，这个陷阱取决于他们对复制的恐惧。

在软件中，复制通常是一件坏事。我们不喜欢有重复的代码。

当代码真正重复时，作为专业人士，我们有义务将其减少和消除。

但是，有不同类型的复制。有真正的复制，在这种情况下，对一个实例进行的每个更改都需要对该实例的每个副本进行相同的更改。然后，有虚假或意外的复制。如果两个明显重复的代码段沿着不同的路径演变，如果它们以不同的速度和不同的原因发生变化，那么它们就不是真正的重复。几年后回头看，你会发现它们彼此非常不同。

现在想象一下，有两个使用情况具有非常相似的屏幕结构。建筑师们很可能会强烈地想要共享该结构的代码。但他们应该吗？这是真正的复制吗？还是偶然的？

很可能是偶然的。随着时间的推移，这两个屏幕会分化，并最终看起来非常不同。因此，必须小心避免将它们统一起来。否则，以后将分离它们将是一个挑战。

当您在垂直地将使用情况彼此分离时，您会遇到这个问题，您的诱惑是将使用情况耦合在一起，因为它们具有相似的屏幕结构、相似的算法、相似的数据库查询和/或模式。要小心。抵制冲动性地消除复制的罪恶。确保复制是真实的。

同样地，当您在水平方向分离层时，您可能会注意到特定数据库记录的数据结构与特定屏幕视图的数据结构非常相似。您可能会被诱惑简单地将数据库记录传递到UI，而不是创建一个外观相同的视图模型并复制元素。小心：这种复制几乎肯定是偶然的。创建单独的视图模型并不需要太多的努力，它将帮助您保持正确解耦的层。

## 分离模式（再次） 

回到模式，有很多方法可以分离层和用例。它们可以在源代码级别、二进制代码（部署）级别和执行单元（服务）级别上分离。 

+ **源级别** 我们可以控制源代码模块之间的依赖关系，使得对一个模块的更改不会强制更改或重新编译其他模块（例如，Ruby Gems）。 在这种分离模式下，组件都在同一地址空间中执行，并使用简单的函数调用相互通信。有一个单一的可执行文件加载到计算机内存中。人们经常称这种结构为单体结构。 
+ **部署级别** 我们可以控制可部署单元之间的依赖关系，例如 jar 文件、DLL 或共享库，使得对一个模块中的源代码的更改不会强制其他模块重新构建和部署。 许多组件仍然可能存在于同一地址空间中，并通过函数调用进行通信。其他组件可能存在于同一处理器中的其他进程中，并通过进程间通信、套接字或共享内存进行通信。这里重要的是，分离的组件被划分为独立可部署的单元，例如 jar 文件、Gem 文件或 DLL。 
+ **服务级别** 我们可以将依赖关系降低到数据结构的水平，并仅通过网络数据包进行通信，使得每个执行单元完全独立于其他执行单元的源代码和二进制代码的更改（例如，服务或微服务）

使用哪种模式最好?

答案是，在早期阶段很难知道哪种模式是最好的

一个项目。实际上，随着项目的成熟，最佳模式可能会发生变化。

例如，不难想象一个系统在上面舒适地运行

现在一个服务器可能会发展到它的一些组件

应该在不同的服务器上运行。当系统运行在单个服务器上时，

源级解耦可能就足够了。然而，以后可能需要

解耦为可部署的单元，甚至服务。

一种解决方案(目前似乎很流行)是简单地在

默认为服务级别。这种方法的一个问题是成本太高

并鼓励粗粒度的解耦。无论微服务变得多么“微”，解耦都不太可能足够细粒度。

服务级解耦的另一个问题是代价昂贵

开发时间和系统资源。处理服务边界

在不需要的地方是浪费精力、内存和周期。是的，我

要知道后两种是便宜的，但第一种不是。

我倾向于将解耦推进到服务可以达到的程度

形成的。如果有必要;然后把这些分量留在

尽可能保持相同的地址空间。这就保留了服务的选项。

使用这种方法，最初在源代码处分离组件

的水平。对于项目生命周期来说，这可能已经足够好了。如果,

但是，会出现部署或开发问题，导致一些

解耦到部署级别可能就足够了——至少在一段时间内是这样。

随着开发、部署和操作问题的增加，我谨慎地

选择将哪些可部署单元转换为服务，并逐步转换

系统在那个方向。

随着时间的推移，系统的操作需求可能会下降。曾经需要什么

服务级别的解耦现在可能只需要部署级别，甚至需要部署级别

源代码级别的解耦。

一个好的架构将允许一个系统作为一个整体诞生，部署在一个

一个小队，然后发展成一组独立部署的小队，然后

然后是独立服务和/或微服务。后来，作为事物

改变，它应该允许逆转这一进程并一路下滑

退回到一块巨石。

一个好的体系结构可以保护大部分源代码不受这些更改的影响。

它将解耦模式作为一个选项打开，以便大型部署可以使用

使用一种模式，而小型部署可以使用另一种模式。

## 结论

是的，这很棘手。我不是说解耦模式的变化

应该是一个简单的配置选项(尽管有时这是合适的)。

我想说的是系统的解耦模式就是其中之一

这可能会随着时间的推移而改变，而一个优秀的架构师能够预见和预测

适当地促进这些更改