# 架构是什么？

“架构”这个词让我们想到权力和神秘感。它让我们想到重大决策和深厚的技术能力。软件架构是技术成就的顶峰。当我们想到一个软件架构师时，我们想到的是一个有权力、受人尊敬的人。哪个年轻有抱负的软件开发人员没有梦想成为一名软件架构师呢？

但是什么是软件架构？软件架构师做什么，以及何时做？

首先，软件架构师是一名程序员；而且仍然是一名程序员。不要相信那种建议软件架构师退回到代码以关注更高级别问题的谎言。他们不会这样做！软件架构师是最好的程序员，他们继续承担编程任务，同时也指导团队朝着最大化生产力的设计方向发展。

软件架构师可能不像其他程序员那样编写那么多的代码，但他们仍然会参与编程任务。他们这样做是因为如果他们不经历他们为其他程序员创建的问题，就无法正常完成工作。

软件系统的架构是由构建它的人所赋予的形状。这种形状的形式是将该系统划分为组件、组件的排列方式以及这些组件彼此之间通信的方式。

这种形状的目的是促进软件系统的开发、部署、操作和维护。

> [!NOTE]
> 支持这种促进的策略是尽可能长时间地保持多种选择。

也许这个说法让你感到惊讶。也许你认为软件架构的目标是使系统正常工作。当然，我们希望系统正常工作，而且系统的架构必须支持这一点作为最高优先事项之一。

然而，一个系统的架构对于该系统是否工作几乎没有影响。有许多系统，它们的架构非常糟糕，但它们工作得很好。它们的问题不在于它们的操作；相反，问题出现在它们的部署、维护和持续开发中。

这并不是说架构在支持系统的正确行为方面没有任何作用。它确实有，而且这个角色是至关重要的。但是这个角色是被动和装饰性的，而不是主动或必要的。系统的架构很少留下任何行为选项。

架构的主要目的是支持系统的生命周期。良好的架构使系统易于理解、易于开发、易于维护和易于部署。最终目标是将系统的寿命周期成本最小化，同时最大化程序员的生产力。

## 开发

一个难以开发的软件系统不太可能有长期健康的寿命。因此，系统的架构应该使得该系统易于开发，以便开发团队能够轻松地开发它。

不同的团队结构意味着不同的架构决策。一方面，由五名开发人员组成的小团队可以相当有效地一起工作，开发一个没有明确定义的组件或接口的单体系统。事实上，这样的团队在开发初期可能会发现架构的限制会阻碍开发。这很可能是为什么许多系统缺乏良好架构的原因：因为开始时没有架构，因为团队很小，不想要超结构的阻碍。

另一方面，由五个不同团队开发的系统，每个团队包括七名开发人员，如果系统没有被划分为具有可靠稳定接口的明确定义的组件，则无法取得进展。如果不考虑其他因素，该系统的架构很可能会发展成五个组件，每个团队一个。

这种按组件划分的架构不太可能是部署、操作和维护系统的最佳架构。然而，如果仅受开发进度的驱动，这是一组团队会倾向于的架构。

## 部署

为了有效，一个软件系统必须是可部署的。部署成本越高，该系统的用处就越小。因此，软件架构的一个目标应该是使系统能够通过单个动作轻松部署。

不幸的是，部署策略很少在初始开发阶段考虑。这导致架构可能使系统易于开发，但使其非常难以部署。

例如，在系统早期开发阶段，开发人员可能决定使用“微服务架构”。他们可能会发现这种方法使得系统非常容易开发，因为组件边界非常明确，接口相对稳定。但是，当到了部署系统的时候，他们可能会发现微服务的数量已经变得令人望而生畏；配置它们之间的连接以及启动时间也可能成为错误的巨大来源。

如果架构师早期考虑了部署问题，他们可能会决定使用较少的服务、服务和进程内组件的混合以及更集成的管理互联方式。

## 运行

架构对系统运行的影响往往不像对开发、部署和维护的影响那么显著。几乎任何操作上的困难都可以通过增加更多的硬件来解决，而不会严重影响软件架构。

事实上，我们已经多次见证了这种情况。具有低效架构的软件系统通常可以通过添加更多的存储和服务器来有效地运行。硬件便宜而人力昂贵的事实意味着，妨碍运行的架构不像妨碍开发、部署和维护的架构那样昂贵。

这并不是说，一个良好调整到系统运行的架构不可取。它是可取的！只是成本方程更倾向于开发、部署和维护。
话虽如此，架构在系统运行中还扮演着另一个角色：良好的软件架构传达了系统的运行需求。

也许更好的说法是，系统的架构使开发人员可以轻松地了解系统的运行。架构应该揭示操作。系统的架构应将系统的用例、功能和所需的行为提升为一流的实体，成为开发人员可见的标志性地标。这简化了对系统的理解，因此在开发和维护方面有很大的帮助。

## 维护

在软件系统的所有方面中，维护是最昂贵的。不断涌现的新功能和不可避免的缺陷和修正消耗了大量的人力资源。

维护的主要成本在于挖掘和风险。挖掘是指通过对现有软件的深入研究，试图确定添加新功能或修复缺陷的最佳位置和最佳策略的成本。在进行这些更改的同时，产生意外缺陷的可能性始终存在，增加了风险成本。

经过深思熟虑的架构极大地减轻了这些成本。通过将系统分解成组件，并通过稳定的接口隔离这些组件，可以为未来功能开辟路径并大大降低意外破坏的风险。

## 保持选项开放

正如我们在早期章节中所描述的那样，软件有两种价值：其行为的价值和其结构的价值。这两者中的第二个是更大的，因为正是这个价值使软件具有软性。

软件的发明是因为我们需要一种快速，轻松地改变机器行为的方式。但这种灵活性关键取决于系统的形状，其组件的排列方式以及这些组件相互连接的方式。

为了让软件保持灵活性，最好让尽可能多的选项尽可能长时间地保持开放状态。哪些选项需要保持开放呢？那些不重要的细节。
所有的软件系统都可以分解为两个主要部分：策略和细节。策略部分包含所有的业务规则和流程，是系统的真正价值所在。

细节是那些为了让人类、其他系统和程序员与策略进行交流而必要的，但并不影响策略行为的那些东西。它们包括IO设备、数据库、Web系统、服务器、框架、通信协议等。

架构师的目标是为系统创建一个形状，认识到策略是系统中最重要的元素，同时使细节对策略不相关。这允许推迟和延迟有关这些细节的决定。

例如：

+ 在开发的早期阶段，选择数据库系统是不必要的，因为高层策略不应关心将使用哪种类型的数据库。事实上，如果架构师小心，高层策略甚至不需要关心数据库是关系型、分布式、分层或纯平面文件。

+ 在开发的早期阶段，选择Web服务器是不必要的，因为高层策略不应知道它是通过Web提供的。如果高层策略不知道HTML、AJAX、JSP、JSF或其他Web开发的字母汤，那么您不需要在项目后期决定使用哪个Web系统。事实上，您甚至不需要决定系统是否将通过Web交付。

+ 在开发的早期阶段，采用REST是不必要的，因为高层策略应该对外部世界的接口持不可知态度。也不需要采用微服务框架或SOA框架。同样，高层策略不应关心这些事情。

+ 在开发的早期阶段，采用依赖注入框架是不必要的，因为高层策略不应关心如何解决依赖关系。

我想你已经明白了重点。如果你可以在不承诺周围细节的情况下制定高级策略，那么你可以延迟和推迟关于这些细节的决定。而且你等待做出这些决定的时间越长，你就会有越多的信息来正确地做出它们。

这也为你留下了尝试不同实验的选择。如果你的高级策略部分运作良好，并且对数据库不关心，那么你可以尝试将其连接到几个不同的数据库来检查适用性和性能。同样的道理也适用于Web系统、Web框架，甚至是Web本身。

你留下的选项越多，你就可以进行越多的实验，尝试更多的事情，并在那些决策无法再被推迟时拥有更多的信息。

如果决定已经由其他人做出怎么办？如果你的公司已经承诺使用特定的数据库、特定的Web服务器或特定的框架怎么办？一个好的架构师会假装决策还没有被做出，并塑造系统，使这些决策仍然可以被推迟或尽可能长时间改变。

> [!NOTE]
> 优秀的架构师会尽量避免做出决策。

## 设备独立性

作为这种思维方式的一个例子，让我们回到上世纪60年代，当时计算机还只是青少年，大多数程序员都是数学家或来自其他学科的工程师（其中三分之一或更多是女性）。

那时候我们犯了很多错误。当然，我们当时不知道这些是错误。我们怎么可能知道呢？

其中一个错误是将我们的代码直接绑定到IO设备上。如果我们需要在打印机上打印东西，我们编写了使用IO指令来控制打印机的代码。我们的代码是设备相关的。

例如，当我编写打印在电传打字机上的PDP-8程序时，我使用了一组看起来像这样的机器指令：

    PRTCHR，0
    TSF
    JMP .-1
    TLS
    JMP I PRTCHR

PRTCHR是一个子程序，用于在电传打字机上打印一个字符。开头的零被用作返回地址的存储器。（别问我为什么。）TSF指令跳过下一个指令，如果电传打字机准备好打印字符。如果电传打字机忙碌，那么TSF就会跳过到JMP .-1指令，它会跳回到TSF指令。如果电传打字机准备好，那么TSF会跳转到TLS指令，将A寄存器中的字符发送到电传打字机。然后，JMP I PRTCHR指令会返回给调用者。

起初，这种策略运作得很好。如果我们需要从读卡器读取卡片，我们使用直接与读卡器通信的代码。如果我们需要打孔卡片，我们编写直接操作打孔机的代码。程序完美运作。我们怎么会知道这是个错误呢？

但是大批量的打孔卡片很难管理。它们可能会丢失、毁坏、混乱、打乱或掉落。单个卡片可能会丢失，额外的卡片可能会被插入。因此，数据完整性成为了一个重要问题。

磁带是解决方案。我们可以将卡片图像移动到磁带上。如果你掉落了磁带，记录不会被打乱。你不会意外丢失一条记录，或者只是通过递送磁带插入一个空记录。磁带更加安全。它读写速度更快，备份很容易。

不幸的是，我们所有的软件都是编写用于操纵读卡器和打卡机的。这些程序必须被重写以使用磁带。这是一项艰巨的工作。

到了1960年代末，我们已经吸取了教训 - 发明了设备独立性。当时的操作系统将IO设备抽象为处理类似卡片的单元记录的软件功能。程序将调用处理抽象单元记录设备的操作系统服务。操作员可以告诉操作系统这些抽象服务是否应该连接到读卡器、磁带或任何其他单元记录设备。

现在同一程序可以读写卡片或读写磁带，而无需进行任何更改。开闭原则诞生了（但还没有被命名）。

## 垃圾邮件

在20世纪60年代末，我曾为一家印刷公司工作，为客户印制垃圾邮件。客户会给我们发送包含客户姓名和地址的单元记录磁带，我们会编写程序，打印漂亮的个性化广告。

你知道的那种：

你好，马丁先生，

恭喜你！

我们从住在女巫林路上的所有人中选择了你参加我们的新奇一次性特惠...

客户会给我们发送大量的表格信函卷，除了姓名和地址以外，所有的字词都已写好，以及他们想要我们打印的任何其他元素。我们编写的程序可以从磁带中提取姓名、地址和其他元素，并将这些元素准确地打印在表格上所需的位置。

这些表格信函的卷轴重达500磅，包含数千封信件。客户会给我们发送数百个这样的卷轴。我们需要逐个打印每一个卷轴。

起初，我们用IBM 360在唯一的线型打印机上打印。我们每个班次可以打印几千封信件。不幸的是，这使得一台非常昂贵的机器长时间被占用。那时，IBM 360每月的租金高达数万美元。

因此，我们告诉操作系统使用磁带而不是线型打印机。我们的程序并不在意，因为它们已经编写成使用操作系统的IO抽象。

360可以在10分钟左右完成一个完整的磁带，足以打印数个表格信函卷。这些磁带被带出机房，连接到离线打印机上的磁带驱动器。我们有五台打印机，每天24小时运行，每周打印数十万封垃圾邮件。

设备独立的价值是巨大的！我们可以编写程序而不必知道或关心使用哪个设备。我们可以使用连接到计算机的本地线型打印机测试这些程序。然后，我们可以告诉操作系统“打印”到磁带上，并打印数十万份表格。

我们的程序有一个形状。这个形状将策略与细节分离。策略是姓名和地址记录的格式。细节是设备。我们推迟了关于使用哪个设备的决定。

## 物理寻址

在 1970 年代初，我参与了一个为本地卡车司机工会开发的大型会计系统。我们有一台 25MB 的硬盘驱动器，用于存储代理、雇主和成员的记录。由于不同的记录大小不同，因此我们将硬盘的前几个柱面格式化，使每个扇区都只能容纳一个代理记录的大小。接下来的几个柱面被格式化为适合雇主记录的扇区大小。最后几个柱面被格式化为适合成员记录的扇区大小。

我们编写了软件来了解硬盘的详细结构。它知道硬盘有 200 个柱面和 10 个磁头，每个柱面有几十个扇区。它知道哪些柱面保存了代理、雇主和成员的记录。所有这些都被硬编码到代码中。

我们在硬盘上保留了一个索引，以便查找每个代理、雇主和成员。这个索引位于另一个特别格式化的硬盘柱面集上。代理索引由包含代理 ID、代理记录所在的柱面号、磁头号和扇区号的记录组成。雇主和成员也有类似的索引。

成员也被保存在硬盘上的双向链表中。每个成员记录保存了下一个成员记录和上一个成员记录的柱面、磁头和扇区号。

如果我们需要升级到一个新的硬盘驱动器，一个具有更多磁头或更多柱面或更多扇区每个柱面的硬盘驱动器，会发生什么情况呢？我们必须编写一个特殊的程序来从旧硬盘中读取旧数据，然后将其写入新硬盘，转换所有柱面/磁头/扇区号。我们还必须更改我们代码中的所有硬编码部分，这些硬编码无处不在！所有业务规则都详细了解柱面/磁头/扇区计划。

一天，一个经验更丰富的程序员加入了我们的行列。当他看到我们所做的时，他的脸色变得苍白，惊骇地盯着我们，仿佛我们是某种外星人。然后，他温和地建议我们更改我们的寻址方案，使用相对地址。

我们的聪明同事建议我们将磁盘视为一个由顺序整数可寻址的巨大线性扇区数组。然后，我们可以编写一个小的转换程序，了解磁盘的物理结构，并可以实时将相对地址转换为柱面/磁头/扇区号。幸运的是，我们接受了他的建议。我们改变了系统的高级策略，使其对磁盘的物理结构不感知。这使我们能够将磁盘驱动器结构的决策与应用程序分离。

## 结论

本章中的两个故事是一个原则的小例子，架构师在大型架构设计中也会采用这个原则。好的架构师会仔细将细节与策略分开，并将策略与细节完全解耦，以至于策略不知道细节，也不以任何方式依赖细节。好的架构师设计策略，以便能够尽可能地推迟和延迟对细节的决策。