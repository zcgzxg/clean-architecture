# 尖叫架构 

想象一下，你正在查看一座建筑的蓝图。这份由建筑师准备的文件提供了建筑的计划。这些计划告诉了你什么？

如果你正在查看的计划是为一座单户住宅准备的，那么你很可能会看到一个前门入口，一个通往客厅的门厅，可能还有一个餐厅。餐厅附近可能会有一个距离不远的厨房。也许厨房旁边还有一个餐厅，很可能还有一个家庭房间就在附近。当你查看这些计划时，毫无疑问你正在看一座单户住宅。建筑会尖叫：“家！”

现在假设你正在查看一座图书馆的建筑。你很可能会看到一个宏伟的入口，一个供应书籍借阅的区域，阅读区域，小型会议室以及无数可以容纳图书馆中所有书籍书架的展览空间。这种建筑会尖叫：“图书馆！”

那么你的应用程序架构会尖叫什么？当你查看顶级目录结构和最高级包中的源文件时，它们会尖叫“医疗保健系统”、“会计系统”或“库存管理系统”吗？还是会尖叫“Rails”、“Spring/Hibernate”或“ASP”？

## 建筑的主题

回到Ivar Jacobson关于软件架构的开创性作品：《面向对象的软件工程》。请注意该书的副标题：一个用例驱动的方法。在这本书中，Jacobson指出，软件架构是支持系统用例的结构。就像房屋或图书馆的计划展现了这些建筑物的用例一样，软件应用的架构也应该展现出应用的用例。

架构不应该（或不应该）是关于框架的。架构不应该由框架提供。框架是工具，而不是要遵循的架构。如果您的架构是基于框架的，那么它就不能基于您的用例。

## 架构的目的

良好的架构应该以用例为中心，以便架构师可以安全地描述支持这些用例的结构，而无需承诺框架、工具和环境。再次考虑房屋的计划。建筑师的首要任务是确保房子是可用的，而不是确保房子是由砖头建造的。实际上，建筑师费尽心思确保房主可以在计划满足用例后，稍后决定外部材料（砖、石头或雪松）。良好的软件架构允许推迟和延迟对框架、数据库、Web服务器和其他环境问题和工具的决策。框架是应该保持开放的选项。良好的架构使得在项目后期才决定使用Rails、Spring、Hibernate、Tomcat或MySQL变得不必要。良好的架构也使得对这些决策的改变变得容易。良好的架构强调用例并将其与周边问题解耦。

## 但是网络呢？

网络是一种架构吗？你的系统是通过网络传递的事实是否决定了你的系统架构？当然不是！网络是一种交付机制-一种IO设备-你的应用程序架构应该将其视为此类设备。你的应用程序通过网络传递是一个细节，不应该支配你的系统结构。实际上，你应该推迟应用程序通过网络传递的决定。你的系统架构应该尽可能地不知道它将如何被交付。你应该能够将其作为控制台应用程序、Web应用程序、厚客户端应用程序甚至Web服务应用程序进行交付，而不需要对基本架构进行过度的复杂化或更改。

## OF LIFE

框架可以非常强大和有用。框架的作者经常深深地相信自己的框架。他们编写的有关如何使用他们的框架的示例是从一个真正信仰者的角度讲述的。其他写作有关框架的作者也往往是真正信仰的追随者。他们向你展示如何使用框架。通常，他们假定一个包罗万象、无所不在、让框架来做所有事情的立场。这不是你想要采取的立场。

以狡猾的眼光看待每个框架。怀疑地看待它。是的，它可能会有所帮助，但代价是什么？问问自己该如何使用它，以及该如何保护自己免受它的影响。考虑一下如何保持你的架构对用例的重视。制定一项策略，防止框架接管该架构。

## 可测试的架构

如果你的系统架构完全关注用例，而且你已经将框架与之保持一定距离，那么你应该能够在没有任何框架的情况下单元测试所有这些用例。你不应该需要启动Web服务器来运行测试。你不应该需要连接数据库来运行测试。你的实体对象应该是普通的对象，没有依赖于框架、数据库或其他复杂性。你的用例对象应该协调你的实体对象。最后，它们应该一起进行现场测试，没有任何框架的复杂性。

## 结论

你的架构应该告诉读者关于系统的信息，而不是关于你在系统中使用的框架的信息。如果你正在构建一个医疗保健系统，那么当新程序员查看源代码库时，他们的第一印象应该是：“哦，这是一个医疗保健系统。”这些新程序员应该能够了解系统的所有用例，但仍然不知道系统是如何交付的。他们可能会来找你，说：

“我们看到一些东西看起来像模型，但视图和控制器在哪里？”

你应该回答道：

“哦，这些都是目前不必关心的细节。我们稍后再决定。”